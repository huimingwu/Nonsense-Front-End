<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JavaScript函数式编程 | 糊说 · 前端</title>
    <meta name="description" content="前端进阶2018">
    <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico">
    
    <link rel="preload" href="/nonsense-front-end/assets/css/14.styles.660e642a.css" as="style"><link rel="preload" href="/nonsense-front-end/assets/js/app.f2e37e93.js" as="script"><link rel="preload" href="/nonsense-front-end/assets/js/4.1d0e363f.js" as="script"><link rel="prefetch" href="/nonsense-front-end/assets/js/8.5a49f5e8.js"><link rel="prefetch" href="/nonsense-front-end/assets/js/1.a386d61b.js"><link rel="prefetch" href="/nonsense-front-end/assets/js/2.30ec5e77.js"><link rel="prefetch" href="/nonsense-front-end/assets/js/3.46d358de.js"><link rel="prefetch" href="/nonsense-front-end/assets/js/5.5882e617.js"><link rel="prefetch" href="/nonsense-front-end/assets/js/6.107f0d23.js"><link rel="prefetch" href="/nonsense-front-end/assets/js/7.7256072f.js"><link rel="prefetch" href="/nonsense-front-end/assets/js/0.6d6198ca.js"><link rel="prefetch" href="/nonsense-front-end/assets/js/9.a4b7e1dd.js"><link rel="prefetch" href="/nonsense-front-end/assets/js/10.ed68d5df.js"><link rel="prefetch" href="/nonsense-front-end/assets/js/11.e50cfcf7.js"><link rel="prefetch" href="/nonsense-front-end/assets/js/12.93c03222.js"><link rel="prefetch" href="/nonsense-front-end/assets/js/13.60f36ed3.js">
    <link rel="stylesheet" href="/nonsense-front-end/assets/css/14.styles.660e642a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/nonsense-front-end/" class="home-link router-link-active"><!----><span class="site-name">
      糊说 · 前端
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="https://segmentfault.com/u/wuhuiming" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/huimingwu/nonsense-front-end" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GITHUB
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><!----></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://segmentfault.com/u/wuhuiming" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/huimingwu/nonsense-front-end" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GITHUB
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><!----></nav><ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>一、JavaScript的新发展</span><!----></p><ul class="sidebar-group-items"><li><a href="/nonsense-front-end/doc/javascript-new-develop/js-functional-programming.html" class="active sidebar-link">1.1 JavaScript函数式编程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/nonsense-front-end/doc/javascript-new-develop/js-functional-programming.html#函数式编程思维" class="sidebar-link">函数式编程思维</a></li><li class="sidebar-sub-header"><a href="/nonsense-front-end/doc/javascript-new-develop/js-functional-programming.html#函数式编程常用核心概念" class="sidebar-link">函数式编程常用核心概念</a></li><li class="sidebar-sub-header"><a href="/nonsense-front-end/doc/javascript-new-develop/js-functional-programming.html#当下函数式编程最热的库" class="sidebar-link">当下函数式编程最热的库</a></li><li class="sidebar-sub-header"><a href="/nonsense-front-end/doc/javascript-new-develop/js-functional-programming.html#函数式编程的实际应用场景" class="sidebar-link">函数式编程的实际应用场景</a></li></ul></li><li><a href="/nonsense-front-end/doc/javascript-new-develop/js-QA.html" class="sidebar-link">1.2 JavaScript与QA测试工程师</a></li><li><a href="/nonsense-front-end/doc/javascript-new-develop/js-quintessence.html" class="sidebar-link">1.3 JavaScript语言精粹</a></li><li><a href="/nonsense-front-end/doc/javascript-new-develop/es-in-enterprise-application.html" class="sidebar-link">1.4 ES6在企业中的应用</a></li><li><a href="/nonsense-front-end/doc/javascript-new-develop/typescript.html" class="sidebar-link">1.5 TypeScript前世今生</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>二、Nodejs 72般变化</span><!----></p><ul class="sidebar-group-items"><li><a href="/nonsense-front-end/doc/nodejs-72s-changes/http.html" class="sidebar-link">2.1 HTTP协议那些事</a></li><li><a href="/nonsense-front-end/doc/nodejs-72s-changes/nodeJS-project-architecture-and-optimization.html" class="sidebar-link">2.2 大规模NodeJS项目架构与优化</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>三、前端工程化那些事</span><!----></p><ul class="sidebar-group-items"><li><a href="/nonsense-front-end/doc/front-end-engineering/1.html" class="sidebar-link">3.1 Linux预备知识</a></li><li><a href="/nonsense-front-end/doc/front-end-engineering/2.html" class="sidebar-link">3.2 从小到大论前端项目持续集成</a></li><li><a href="/nonsense-front-end/doc/front-end-engineering/3.html" class="sidebar-link">3.3 前端架构那些事儿</a></li><li><a href="/nonsense-front-end/doc/front-end-engineering/4.html" class="sidebar-link">3.4 WebPack从入门到放弃</a></li><li><a href="/nonsense-front-end/doc/front-end-engineering/5.html" class="sidebar-link">3.5 前端工程化预备知识</a></li><li><a href="/nonsense-front-end/doc/front-end-engineering/6.html" class="sidebar-link">3.6 FIS从入门到放弃</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>更新中...</span><!----></p><ul class="sidebar-group-items"></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="javascript函数式编程"><a href="#javascript函数式编程" aria-hidden="true" class="header-anchor">#</a> JavaScript函数式编程</h1><p></p><div class="table-of-contents"><ul><li><a href="#函数式编程思维">函数式编程思维</a><ul><li><a href="#范畴论">范畴论</a></li><li><a href="#函数式编程基础理论">函数式编程基础理论</a></li></ul></li><li><a href="#函数式编程常用核心概念">函数式编程常用核心概念</a><ul><li><a href="#一些专业术语（纯函数、函数的柯里化、函数组合、pointfree、声明式与命令式代码、惰性求值）">一些专业术语（纯函数、函数的柯里化、函数组合、PointFree、声明式与命令式代码、惰性求值）</a></li><li><a href="#更多的专业术语（高阶函数、尾调用优化、闭包、容器、functor、错误处理-either-ap、io、monad）">更多的专业术语（高阶函数、尾调用优化、闭包、容器、Functor、错误处理/Either/AP、IO、Monad）</a></li></ul></li><li><a href="#当下函数式编程最热的库">当下函数式编程最热的库</a><ul><li><a href="#rxjs">RxJS</a></li><li><a href="#cyclejs">cycleJS</a></li><li><a href="#lodashjs、lazy-惰性求值">lodashJS、lazy(惰性求值)</a></li><li><a href="#underscorejs">underscoreJS</a></li><li><a href="#ramdajs">ramdajs</a></li></ul></li><li><a href="#函数式编程的实际应用场景">函数式编程的实际应用场景</a><ul><li><a href="#易调试、热部署、并发">易调试、热部署、并发</a></li><li><a href="#单元测试">单元测试</a></li><li><a href="#小结与补充">小结与补充</a></li></ul></li></ul></div><p></p><h2 id="函数式编程思维"><a href="#函数式编程思维" aria-hidden="true" class="header-anchor">#</a> 函数式编程思维</h2><h3 id="范畴论"><a href="#范畴论" aria-hidden="true" class="header-anchor">#</a> 范畴论</h3><ul><li>函数式编程是范畴论的数学分支，是一门很复杂的数学，认为世界上所有概念体系都可以抽象出一个个范畴。</li><li>彼此之间存在某种关系概念、事物、对象等等，都构成范畴。任何事物只要找出他们之间的关系，就能定义</li><li>箭头表示范畴成员之间的关系，正式的名称叫做&quot;态射&quot;（morphism）。范畴论认为，同一个范畴的所有成员，就是不同状态的&quot;变形（transformation）。通过&quot;态射&quot;，一个成员可以变形成另一个成员。</li></ul><p>图1</p><ol><li>所有成员都是一个集合</li><li>变形关系是函数</li></ol><h3 id="函数式编程基础理论"><a href="#函数式编程基础理论" aria-hidden="true" class="header-anchor">#</a> 函数式编程基础理论</h3><ul><li>函数式编程（Functional Programming）其实相对于计算机的历史而言是一个非常古老的概念，甚至早于第一台计算机的诞生。函数式编程的基础模型来源于 λ (Lambda x=&gt;x*2)演算，而 λ 演算并非设计于在计算机上执行，它是在 20 世纪三十年代引入的一套用于研究函数定义、函数应用和递归的形式系统。</li><li>函数式编程不是用函数来编程，也不是传统的面向过程编程。主旨在于将复杂的函数符合成简单的函数（计算理论，或者递归论，或者拉姆达演算）。运算过程尽量写成一系列嵌套的函数调用。</li><li>JavaScript 是披着 C 外衣的 Lisp。</li><li>真正的火热是随着React的高阶函数而逐步升温。</li><li>函数是一等公民。所谓”第一等公民”（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数,传入另一个函数，或者作为别的函数的返回值。</li><li>不可改变量。在函数式编程中，我们通常理解的变量在函数式编程中也被函数代替了：在函数式编程中变量仅仅代表某个表达式。这里所说的’变量’是不能被修改的。所有的变量只能被赋一次初值</li><li>map &amp; reduce他们是最常用的函数式编程的方法</li></ul><p>小结：</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>1.函数是“一等公民”<br>
2.只用“表达式”，不用“语句”<br>
3.没有“副作用”<br>
4.不修改状态<br>
5.引用透明（函数运行只靠参数）</p></div><h2 id="函数式编程常用核心概念"><a href="#函数式编程常用核心概念" aria-hidden="true" class="header-anchor">#</a> 函数式编程常用核心概念</h2><h3 id="一些专业术语（纯函数、函数的柯里化、函数组合、pointfree、声明式与命令式代码、惰性求值）"><a href="#一些专业术语（纯函数、函数的柯里化、函数组合、pointfree、声明式与命令式代码、惰性求值）" aria-hidden="true" class="header-anchor">#</a> 一些专业术语（纯函数、函数的柯里化、函数组合、PointFree、声明式与命令式代码、惰性求值）</h3><div class="language- extra-class"><pre class="language-text"><code>1.纯函数
2.函数的柯里化
3.函数组合
4.PointFree
5.声明式与命令式代码
6.惰性求值
</code></pre></div><p>1、纯函数<br>
对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。</p><div class="language- extra-class"><pre class="language-text"><code>var xs = [1,2,3,4,5];// Array.slice是纯函数，因为它没有副作用，对于固定的输入，输出总是固定的
xs.slice(0,3);
xs.slice(0,3);
xs.splice(0,3);
xs.splice(0,3);
</code></pre></div><p>优缺点：</p><ul><li>缺1</li><li>缺1</li></ul><p>2、函数的柯里化<br>
传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。
我们一起来用柯里化来改他：</p><div class="language- extra-class"><pre class="language-text"><code>var checkage = min =&gt; (age =&gt; age &gt; min);
var checkage18 = checkage(18);
checkage18(20);
</code></pre></div><p>函数的柯里化code</p><div class="language- extra-class"><pre class="language-text"><code>// 柯⾥化之前
function add(x, y) {
    return x + y;
}
add(1, 2) // 3
// 柯⾥化之后
function addX(y) {
    return function (x) {
        return x + y;
    };
}
addX(2)(1) // 3
</code></pre></div><p>优缺点</p><div class="language- extra-class"><pre class="language-text"><code>import { curry } from 'lodash';
var match = curry((reg, str) =&gt; str.match(reg));
var filter = curry((f, arr) =&gt; arr.filter(f));
var haveSpace = match(/\s+/g);
//haveSpace(“ffffffff”);
//haveSpace(“a b&quot;);
//filter(haveSpace, [&quot;abcdefg&quot;, &quot;Hello World&quot;]);
filter(haveSpace)([&quot;abcdefg&quot;, &quot;Hello World&quot;])
</code></pre></div><p>事实上柯里化是一种“预加载”函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲， 这是一种对参数的“缓存”，是一种非常高效的编写函数的方法。</p><p>3、函数组合<br>
纯函数以及如何把它柯里化写出的洋葱代码 h(g(f(x)))，为了解决函数嵌套的问题，我们需要用到“函数组合”：我们一起来用柯里化来改他，让多个函数像拼积木一样</p><div class="language- extra-class"><pre class="language-text"><code>const compose = (f, g) =&gt; (x =&gt; f(g(x)));
var first = arr =&gt; arr[0];
var reverse = arr =&gt; arr.reverse();
var last = compose(first, reverse);
last([1,2,3,4,5]);
</code></pre></div><p>图2</p><div class="language- extra-class"><pre class="language-text"><code>compose(f,compose(g,h))
compose(compose(f,g),h)
compose(f,g,h)
</code></pre></div><p>4、PointFree</p><ul><li>把一些对象自带的方法转化成纯函数,不要命名转瞬即逝的中间变量。</li><li>这个函数中，我们使用了 str 作为我们的中间变量，但这个中间变量除了让代码变得长了一点以外是毫无意义的。</li></ul><div class="language- extra-class"><pre class="language-text"><code>const f = str =&gt; str.toUpperCase().split(' ');
</code></pre></div><p>优缺点</p><div class="language- extra-class"><pre class="language-text"><code>var toUpperCase = word =&gt; word.toUpperCase();
var split = x =&gt; (str =&gt; str.split(x));
var f = compose(split(' '), toUpperCase);
f(&quot;abcd efgh&quot;);
</code></pre></div><p>这种风格能够帮助我们减少不必要的命名，让代码保持简洁和通用。</p><p>5、声明式与命令式代码<br>
命令式代码的意思就是，我们通过编写一条又一条指令去让计算机执行一些动作，这其中一般都会涉及到很多繁杂的细节。而声明式就要优雅很多了，我们通过写表达式的方式来声明我们想干什么，而不是通过一步一步的指示。</p><div class="language- extra-class"><pre class="language-text"><code>//命令式
let CEOs = [];
for(var i = 0; i &lt; companies.length; i++)
    CEOs.push(companies[i].CEO)
}
//声明式
let CEOs = companies.map(c =&gt; c.CEO);
</code></pre></div><p>优缺点</p><ul><li>函数式编程的一个明显的好处就是这种声明式的代码，对于无副作用的纯函数，我们完全可以不考虑函数内部是如何实现的，专注于编写业务代码。优化代码时，目光只需要集中在这些稳定坚固的函数内部即可。</li><li>相反，不纯的函数式的代码会产生副作用或者依赖外部系统环境，使用它们的时候总是要考虑这些不干净的副作用。在复杂的系统中，这对于程序员的心智来说是极大的负担。</li></ul><p>6、惰性求值<br>
在指令式语言中以下代码会按顺序执行，由于每个函数都有可能改动或者依赖于其外部的状态，因此必须顺序执行。</p><div class="language- extra-class"><pre class="language-text"><code>function somewhatLongOperation1(){somewhatLongOperation1}
</code></pre></div><h3 id="更多的专业术语（高阶函数、尾调用优化、闭包、容器、functor、错误处理-either-ap、io、monad）"><a href="#更多的专业术语（高阶函数、尾调用优化、闭包、容器、functor、错误处理-either-ap、io、monad）" aria-hidden="true" class="header-anchor">#</a> 更多的专业术语（高阶函数、尾调用优化、闭包、容器、Functor、错误处理/Either/AP、IO、Monad）</h3><div class="language- extra-class"><pre class="language-text"><code>7.高阶函数
8.尾调用优化
9.闭包
10.容器、Functor
11.错误处理、Either、AP
12.IO
13.Monad
</code></pre></div><p>7、高阶函数<br>
函数当参数，把传入的函数做一个封装，然后返回这个封装函数,达到更高程度的抽象。</p><div class="language- extra-class"><pre class="language-text"><code>//命令式
var add = function(a,b){ 
    return a + b;
};
function math(func,array){ 
    return func(array[0],array[1]);
}
math(add,[1,2]); // 3
</code></pre></div><p>8、尾调用优化<br>
指函数内部的最后一个动作是函数调用。该调用的返回值，直接返回给函数。函数调用自身，称为递归。如果尾调用自身，就称为尾递归。递归需要保存大量的调用记录，很容易发生栈溢出错误，如果使用尾递归优化，将递归变为循环，那么只需要保存一个调用记录，这样就不会发生栈溢出错误了。</p><div class="language- extra-class"><pre class="language-text"><code>// 不是尾递归，无法优化
function factorial(n) { 
    if (n === 1) return 1;
        return n * factorial(n - 1);
}
function factorial(n, total) { 
    if (n === 1) return total;
        return factorial(n - 1, n * total);
} //ES6强制使用尾递归
</code></pre></div><p>普通递归时，内存需要记录调用的堆栈所出的深度和位置信息。在最底层计算返回值，再根据记录的信息，跳回上一层级计算，然后再跳回更高一层，依次运行，直到最外层的调用函数。在cpu计算和内存会消耗很多，而且当深度过大时，会出现堆栈溢出</p><div class="language- extra-class"><pre class="language-text"><code>function sum(n) { 
    if (n === 1) return 1;
        return n + sum(n - 1);
}
//-&gt;
sum(5)
(5 + sum(4))
(5 + (4 + sum(3)))
(5 + (4 + (3 + sum(2))))
(5 + (4 + (3 + (2 + sum(1)))))
(5 + (4 + (3 + (2 + 1))))
(5 + (4 + (3 + 3)))
(5 + (4 + 6))
(5 + 10)
15
</code></pre></div><p>整个计算过程是线性的，调用一次sum(x, total)后，会进入下一个栈，相关的数据信息和跟随进入，不再放在堆栈上保存。当计算完最后的值之后，直接返回到最上层的sum(5,0)。这能有效的防止堆栈溢出。在ECMAScript 6，我们将迎来尾递归优化，通过尾递归优化，javascript代码在解释成机器码的时候，将会向while看起，也就是说，同时拥有数学表达能力和while的效能。</p><div class="language- extra-class"><pre class="language-text"><code>function sum(x, total) {
    if (x === 1) {
        return x + total;
    }
    return sum(x - 1, x + total);
}
sum(5, 0)
sum(4, 5)
sum(3, 9)
sum(2, 12)
sum(1, 14)
15
</code></pre></div><p>9、闭包<br>
如下例子，虽然外层的 makePowerFn 函数执行完毕，栈上的调用帧被释放，但是堆上的作用域并不被释放，因此 power 依旧可以被 powerFn 函数访问，这样就形成了闭包</p><div class="language- extra-class"><pre class="language-text"><code>function makePowerFn(power) {
    function powerFn(base) {
        return Math.pow(base, power);
    }
    return powerFn;
}
var square = makePowerFn(2);
square(3); // 9
</code></pre></div><p>10、容器、Functor<br>
范畴与容器</p><ul><li>我们可以把”范畴”想象成是一个容器，里面包含两样东西。值（value）、值的变形关系，也就是函数。</li><li>范畴论使用函数，表达范畴之间的关系。</li><li>伴随着范畴论的发展，就发展出一整套函数的运算方法。这套方法起初只用于数学运算，后来有人将它在计算机上实现了，就变成了今天的”函数式编程&quot;。</li><li>本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了。</li><li>函数不仅可以用于同一个范畴之中值的转换，还可以用于将一个范畴转成另一个范畴。这就涉及到了函子（Functor）。</li><li>函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。它首先是一种范畴，也就是说，是一个容器，包含了值和变形关系。比较特殊的是，它的变形关系可以依次作用于每一个值，将当前容器变形成另一个容器</li></ul><p>图3</p><p>容器、Functor（函子）</p><ul><li>$(...) 返回的对象并不是一个原生的 DOM 对象，而是对于原生对象的一种封装，这在某种意义上就是一个“容器”（但它并不函数式）。</li><li>Functor（函子）遵守一些特定规则的容器类型。</li><li>Functor 是一个对于函数调用的抽象，我们赋予容器自己去调用函数的能力。把东西装进一个容器，只留出一个接口 map 给容器外的函数，map 一个函数时，我们让容器自己来运行这个函数，这样容器就可以自由地选择何时何地如何操作这个函数，以致于拥有惰性求值、错误处理、异步调用等等非常牛掰的特性。</li></ul><p>函子的代码实现</p><ul><li>任何具有map方法的数据结构，都可以当作函子的实现。</li><li>Functor（函子）遵守一些特定规则的容器类型。</li><li>Functor 是一个对于函数调用的抽象，我们赋予容器自己去调用函数的能力。把东西装进一个容器，只留出一个接口map 给容器外的函数，map 一个函数时，我们让容器自己来运行这个函数，这样容器就可以自由地选择何时何地如何操作这个函数，以致于拥有惰性求值、错误处理、异步调用等等非常牛掰的特性。</li></ul><div class="language- extra-class"><pre class="language-text"><code>var Container = function(x) {
    this.__value = x;
}
//函数式编程一般约定，函子有一个of方法
Container.of = x =&gt; new Container(x);
//Container.of(‘abcd’);
//一般约定，函子的标志就是容器具有map方法。该方法将容器
里面的每一个值，映射到另一个容器。
Container.prototype.map = function(f){
    return Container.of(f(this.__value))
}
Container.of(3)
    .map(x =&gt; x + 1) //=&gt; Container(4)
    .map(x =&gt; 'Result is ' + x); //=&gt; Container('Result is 4')
</code></pre></div><p>map</p><div class="language- extra-class"><pre class="language-text"><code>class Functor {
    constructor(val) {
        this.val = val;
    }
    map(f) {
        return new Functor(f(this.val));
    }
}
(new Functor(2)).map(function (two) {
    return two + 2;
});
// Functor(4)
</code></pre></div><p>上面代码中，Functor是一个函子，它的map方法接受函数f作为参数，然后返回一个新的函子，里面包含的值是被f处理过的（f(this.val)）。<br>
一般约定，函子的标志就是容器具有map方法。该方法将容器里面的每一个值，映射到另一个容器。<br>
上面的例子说明，函数式编程里面的运算，都是通过函子完成，即运算不直接针对值，而是针对这个值的容器----函子。函子本身具有对外接口（map法），各种函数就是运算符，通过接口接入容器，引发容器里面的值的变形。<br>
因此，学习函数式编程，实际上就是学习函子的各种运算。由于可以把运算方法封装在函子里面，所以又衍生出各种不同类型的函子，有多少种运算，就有多少种函子。函数式编程就变成了运用不同的函子，解决实际问题。</p><p>of方法<br>
你可能注意到了，上面生成新的函子的时候，用了
new命令。这实在太不像函数式编程了，因为new命令是
面向对象编程的标志。
函数式编程一般约定，函子有一个of方法，用来生成新
的容器。</p><div class="language- extra-class"><pre class="language-text"><code>Functor.of = function(val) {
    return new Functor(val);
}; 
Functor.of(2).map(function (two) {
    return two + 2;
});
// Functor(4)
</code></pre></div><p>Maybe函子<br>
函子接受各种函数，处理容器内部的值。这里就有一个问题，容器内部的值可能是一个空值（比如null），而外部函数未必有处理空值的机制，如果传入空值，很可能就会出错。</p><div class="language- extra-class"><pre class="language-text"><code>Functor.of(null).map(function (s) {
    return s.toUpperCase();
});
// TypeError
class Maybe extends Functor {
map(f) {
    return this.val ? Maybe.of(f(this.val)) : Maybe.of(null);
}
}
Maybe.of(null).map(function (s) {
    return s.toUpperCase();
});
// Maybe(null)
var Maybe = function(x) {
    this.__value = x;
}
Maybe.of = function(x) {
    return new Maybe(x);
}
Maybe.prototype.map = function(f) {
    return this.isNothing() ? Maybe.of(null) : Maybe.of(f(this.__value));
}
Maybe.prototype.isNothing = function() {
    return (this.__value === null || this.__value === undefined);
}
//新的容器我们称之为 Maybe（原型来自于Haskell）
</code></pre></div><p>11、错误处理、Either、AP<br>
错误处理、Either</p><ul><li>我们的容器能做的事情太少了，try/catch/throw 并不是“纯”的，因为它从外部接管了我们的函数，并且在这个函数出错时抛弃了它的返回值。</li><li>Promise 是可以调用 catch 来集中处理错误的。</li><li>事实上 Either 并不只是用来做错误处理的，它表示了逻辑或，范畴学里的 coproduc。</li></ul><p>Either<br>
条件运算if...else是最常见的运算之一，函数式编程里面，使用 Either 函子表达。Either 函子内部有两个值：左值（Left）和右值（Right）。右值是正常情况下使用的值，左值是右值不存在时使用的默认值。</p><div class="language- extra-class"><pre class="language-text"><code>class Either extends Functor {
    constructor(left, right) {
        this.left = left;
        this.right = right;
    }
    map(f) {
        return this.right ?
        Either.of(this.left, f(this.right)) :
        Either.of(f(this.left), this.right);
    }
}
Either.of = function (left, right) {
    return new Either(left, right);
};
var addOne = function (x) {
    return x + 1;
};
Either.of(5, 6).map(addOne);
// Either(5, 7);
Either.of(1, null).map(addOne);
// Either(2, null);
Either
    .of({address: 'xxx'}, currentUser.address)
    .map(updateField);
</code></pre></div><p>代替try...catch</p><div class="language- extra-class"><pre class="language-text"><code>var Left = function(x) {
    this.__value = x;
}
var Right = function(x) {
    this.__value = x;
}
Left.of = function(x) {
    return new Left(x);
}
Right.of = function(x) {
    return new Right(x);
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// 这⾥不同！！！
Left.prototype.map = function(f) {
    return this;
}
Right.prototype.map = function(f) {
    return Right.of(f(this.__value));
}
</code></pre></div><p>Left 和 Right 唯一的区别就在于 map 方法的实现，Right.map 的行为和我们之前提到的 map 函数一样。但是 Left.map 就很不同了：它不会对容器做任何事情，只是很简单地把这个容器拿进来又扔出去。这个特性意味着，Left 可以用来传递一个错误消息。</p><div class="language- extra-class"><pre class="language-text"><code>var getAge = user =&gt; user.age ? Right.of(user.age) :
Left.of(&quot;ERROR!&quot;);

getAge({name: 'stark', age: '21'}).map(age =&gt; 'Age is ' + age);
//=&gt; Right('Age is 21')

getAge({name: 'stark'}).map(age =&gt; 'Age is ' + age);
//=&gt; Left('ERROR!')
</code></pre></div><p>Left 可以让调用链中任意一环的错误立刻返回到调用链的尾部，这给我们错误处理带来了很大的方便，再也不用一层又一层的try/catch。</p><p>AP因子<br>
函子里面包含的值，完全可能是函数。我们可以想象这样一种情况，一个函子的值是数值，另一个函子的值是函数。</p><div class="language- extra-class"><pre class="language-text"><code>class Ap extends Functor {
    ap(F) {
        return Ap.of(this.val(F.val));
    }
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>class Ap extends Functor {
    ap(F) {
        return Ap.of(this.val(F.val));
    }
}
Ap.of(addTwo).ap(Functor.of(2))
</code></pre></div><p>12、IO</p><ul><li>真正的程序总要去接触肮脏的世界。</li></ul><div class="language- extra-class"><pre class="language-text"><code>function readLocalStorage(){
    return window.localStorage;
}
</code></pre></div><ul><li>IO 跟前面那几个 Functor 不同的地方在于，它的 __value 是一个函数。它把不纯的操作（比如 IO、网络请求、DOM）包裹到一个函数内，从而延迟这个操作的执行。所以我们认为，IO 包含的是被包裹的操作的返回值。</li><li>IO其实也算是惰性求值。</li><li>IO负责了调用链积累了很多很多不纯的操作，带来的复杂性和不可维护性</li></ul><div class="language- extra-class"><pre class="language-text"><code>import _ from 'lodash';
var compose = _.flowRight;
var IO = function(f) {
    this.__value = f;
}
IO.of = x =&gt; new IO(_ =&gt; x);
IO.prototype.map = function(f) {
    return new IO(compose(f, this.__value))
};
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>import _ from 'lodash';
var compose = _.flowRight;
class IO extends Monad{
    map(f){
        return IO.of(compose(f, this.__value))
    }
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>var fs = require('fs');
var readFile = function(filename) {
    return new IO(function() {
        return fs.readFileSync(filename, 'utf-8');
    });
};
readFile('./user.txt')
    .flatMap(tail)
    .flatMap(print)
// 等同于
readFile('./user.txt')
    .chain(tail)
    .chain(print)
</code></pre></div><p>我们先后提到了 Maybe、Either、IO 这三种强大的 Functor，在链式调用、惰性求值、错误捕获、输入输出中都发挥着巨大的作用。事实上 Functor 远不止这三种。<br>
但依然有问题困扰着我们：</p><ol><li>如何处理嵌套的 Functor 呢？（比如 Maybe(IO(42))）</li><li>如何处理一个由非纯的或者异步的操作序列呢？</li></ol><p>图4</p><p>数据类型<br>
数据类型就是对值的一种封装，不仅包括值本身，还包括相关的属性和方法。2就不是一个单纯的值，而是一种数据类型的实例，只能在数据类型的场景（context）中使用。
图5<br>
图6<br>
图7<br>
13、Monad</p><ul><li>Monad就是一种设计模式，表示将一个运算过程，通过函数拆解成互相连接的多个步骤。你只要提供下一步运算所需的函数，整个运算就会自动进行下去。</li><li>Promise 就是一种 Monad。</li><li>Monad让我们避开了嵌套地狱，可以轻松地进行深度嵌套的函数式编程，比如IO和其它异步任务。</li></ul><div class="language- extra-class"><pre class="language-text"><code>Maybe.of(
    Maybe.of(
        Maybe.of({name:	'Mulburry',	number:	8402})
    )
)
class Monad	extends	Functor	{
    join()	{
        return this.val;
    }
    flatMap(f)	{
        return	this.map(f).join();	
    }
}
</code></pre></div><p>Monad函⼦的作⽤是，总是返回⼀个单层的函⼦。它有⼀个flatMap⽅法，与map⽅法作⽤相同，唯⼀的区别是如果⽣成了⼀个嵌套函⼦，它会取出后者内部的值，保证返回的永远是⼀个单层的容器，不会出现嵌套的情况。<br>
如果函数f返回的是⼀个函⼦，那么this.map(f)就会⽣成⼀个嵌套的函⼦。所以， join⽅法保证了flatMap⽅法总是返回⼀个单层的函⼦。这意味着嵌套的函⼦会被铺平（ flatten）。</p><h2 id="当下函数式编程最热的库"><a href="#当下函数式编程最热的库" aria-hidden="true" class="header-anchor">#</a> 当下函数式编程最热的库</h2><div class="language- extra-class"><pre class="language-text"><code>1.RxJS
2.cycleJS
3.lodashJS、lazy(惰性求值)
4.underscoreJS
5.ramdajs
</code></pre></div><h3 id="rxjs"><a href="#rxjs" aria-hidden="true" class="header-anchor">#</a> RxJS</h3><p>图8<br>
Rxjs 从诞生以来一直都不温不火，但它函数响应式编程（Functional Reactive Programming，FRP）的理念非常先进，虽然或许对于大部分应用环境来说，外部输入事件并不是太频繁，并不需要引入一个如此庞大的 FRP 体系，但我们也可以了解一下它有哪些优秀的特性  在 Rxjs 中，所有的外部输入（用户输入、网络请求等等）都被视作一种 『事件流』：<br>
用户点击了按钮 --&gt; 网络请求成功 --&gt; 用户键盘输入 --&gt; 某个定时事件发生 —&gt; 这种事件流特别适合处理游戏，上上下下上上下下<br>
举个最简单的例子，下面这段代码会监听点击事件，每 2 次点击事件产生一次事件响应：</p><div class="language- extra-class"><pre class="language-text"><code>var clicks = Rx.Observable
.fromEvent(document, 'click')
.bufferCount(2)
.subscribe(x =&gt; console.log(x)); // 打印出前2次点击事件
</code></pre></div><p>响应式编程是继承自函数式编程，声明式的，不可变的，没有副作用的是函数式编程的三大护法。其中不可变武功最高深。一直使用面向对象范式编程的我们，习惯了用变量存储和追踪程序的状态。RxJS从函数式编程范式中借鉴了很多东西，比如链式函数调用，惰性求值等等。<br>
在函数中与函数作用域之外的一切事物有交互的就产生了副作用。比如读写文件，在控制台打印语句，修改页面元素的css等等。在RxJS中，把副作用问题推给了订阅者来解决。</p><h3 id="cyclejs"><a href="#cyclejs" aria-hidden="true" class="header-anchor">#</a> cycleJS</h3><p>Cycle.js 是一个基于 Rxjs 的框架，它是一个彻彻底底的 FRP 理念的框架，和 React 一样支持 virtual DOM、JSX 语法，但现在似乎还没有看到大型的应用经验。<br>
本质的讲，它就是在 Rxjs 的基础上加入了对 virtual DOM、容器和组件的支持，比如下面就是一个简单的『开关』按钮：</p><div class="language- extra-class"><pre class="language-text"><code>function main(sources) {
    const sinks = {
        DOM: sources.DOM.select('input').events('click')
        .map(ev =&gt; ev.target.checked)
        .startWith(false)
        .map(toggled =&gt;
        &lt;div&gt;
            &lt;input type=&quot;checkbox&quot; /&gt; Toggle me
            &lt;p&gt;{toggled ? 'ON' : 'off'}&lt;/p&gt;
        &lt;/div&gt;
    )
};
return sinks;
}
const drivers = {
DOM: makeDOMDriver('#app')
};
run(main, drivers);
</code></pre></div><h3 id="lodashjs、lazy-惰性求值"><a href="#lodashjs、lazy-惰性求值" aria-hidden="true" class="header-anchor">#</a> lodashJS、lazy(惰性求值)</h3><p>lodashJS<br>
lodash是一个具有一致接口、模块化、高性能等特性的JavaScript工具库，是underscore.js的fork，其最初目标也是“一致的跨浏览器行为。。。，并改善性能”。<br>
lodash采用延迟计算，意味着我们的链式方法在显式或者隐式的value()调用之前是不会执行的，因此lodash可以进行shortcut（捷径） fusion（融合）这样的优化，通过合并链式大大降低迭代的次数，从而大大提升其执行性能。<br>
就如同jQuery在全部函数前加全局的$一样，lodash使用全局的_来提供对工具的快速访问。</p><div class="language- extra-class"><pre class="language-text"><code>var abc = function(a, b, c) {
    return [a, b, c];
};
var curried = _.curry(abc);
curried(1)(2)(3);
function square(n) {
    return n * n;
}
var addSquare = _.flowRight(square, _.add);
addSquare(1, 2);
// =&gt; 9
</code></pre></div><h3 id="underscorejs"><a href="#underscorejs" aria-hidden="true" class="header-anchor">#</a> underscoreJS</h3><p>Underscore 是一个 JavaScript 工具库，它提供了一整套函数式编程的实用功能，但是没有扩展任何 JavaScript 内置对象。 他解决了这个问题：“如果我面对一个空白的 HTML 页面，并希望立即开始工作，我需要什么？” 他弥补了 jQuery 没有实现的功能，同时又是 Backbone 必不可少的部分。<br>
Underscore 提供了100多个函数，包括常用的：map、filter、invoke——当然还有更多专业的辅助函数，如：函数绑定、JavaScript 模板功能、创建快速索引、强类型相等测试等等。</p><h3 id="ramdajs"><a href="#ramdajs" aria-hidden="true" class="header-anchor">#</a> ramdajs</h3><p>ramda是一个非常优秀的js工具库，跟同类比 更函数式主要体现在以下几个原则</p><ul><li>ramda里面的提供的函数全部都是curry的 意味着函数没有默认参
数可选参数从而减轻认知函数的难度。</li><li>ramda推崇pointfree简单的说是使用简单函数组合实现一个复杂
功能，而不是单独写一个函数操作临时变量。</li><li>ramda有个非常好用的参数占位符 R._ 大大减轻了函数在pointfree过程中参数位置的问题</li></ul><p>相比underscore/lodash 感觉要干净很多。</p><h2 id="函数式编程的实际应用场景"><a href="#函数式编程的实际应用场景" aria-hidden="true" class="header-anchor">#</a> 函数式编程的实际应用场景</h2><h3 id="易调试、热部署、并发"><a href="#易调试、热部署、并发" aria-hidden="true" class="header-anchor">#</a> 易调试、热部署、并发</h3><ul><li>函数式编程中的每个符号都是 const 的，于是没有什么函数会有副作用。谁也不能在运行时修改任何东西，也没有函数可以修改在它的作用域之外修改什么值给其他函数继续使用。这意味着决定函数执行结果的唯一因素就是它的返回值，而影响其返回值的唯一因素就是它的参数。</li><li>函数式编程不需要考虑”死锁&quot;（deadlock），因为它不修改变量，所以根本不存在&quot;锁&quot;线程的问题。不必担心一个线程的数据，被另一个线程修改，所以可以很放心地把工作分摊到多个线程，部署&quot;并发编程&quot;（concurrency）。</li><li>函数式编程中所有状态就是传给函数的参数，而参数都是储存在栈上的。这一特性让软件的热部署变得十分简单。只要比较一下正在运行的代码以及新的代码获得一个diff，然后用这个diff更新现有的代码，新代码的热部署就完成了。</li></ul><h3 id="单元测试"><a href="#单元测试" aria-hidden="true" class="header-anchor">#</a> 单元测试</h3><ul><li>严格函数式编程的每一个符号都是对直接量或者表达式结果的引用，没有函数产生副作用。因为从未在某个地方修改过值，也没有函数修改过在其作用域之外的量并被其他函数使用（如类成员或全局变量）。这意味着函数求值的结果只是其返回值，而惟一影响其返回值的就是函数的参数。</li><li>这是单元测试者的梦中仙境(wet dream)。对被测试程序中的每个函数，你只需在意其参数，而不必考虑函数调用顺序，不用谨慎地设置外部状态。所有要做的就是传递代表了边际情况的参数。如果程序中的每个函数都通过了单元测试，你就对这个软件的质量有了相当的自信。而命令式编程就不能这样乐观了，在 Java 或 C++ 中只检查函数的返回值还不够——我们还必须验证这个函数可能修改了的外部状态。</li></ul><h3 id="小结与补充"><a href="#小结与补充" aria-hidden="true" class="header-anchor">#</a> 小结与补充</h3><p>函数式编程不应被视为灵丹妙药。相反，它应该被视为我们现有工具箱的一个很自然的补充——它带来了更高的可组合性，灵活性以及容错性。现代的JavaScript库已经开始尝试拥抱函数式编程的概念以获取这些优势。Redux 作为一种 FLUX的变种实现，核心理念也是状态机和函数式编程。</p><p>我们本节课介绍了纯函数、柯里化、Point Free、声明式代码和命令式代码的区别，只要记住『函数对于外部状态的依赖是造成系统复杂性大大提高的主要原因』以及『让函数尽可能地纯净』就行了。</p><p>然后介绍了『容器』的概念和 Maybe、Either、IO 这三个强大的 Functor。是的，大多数人或许都没有机会在生产环境中自己去实现这样的玩具级 Functor，但通过了解它们的特性会让你产生对于函数式编程的意识。</p><p>软件工程上讲『没有银弹』，函数式编程同样也不是万能的，它与烂大街的 OOP一样，只是一种编程范式而已。很多实际应用中是很难用函数式去表达的，选择OOP 亦或是其它编程范式或许会更简单。但我们要注意到函数式编程的核心理念，如果说 OOP 降低复杂度是靠良好的封装、继承、多态以及接口定义的话，那么函数式编程就是通过纯函数以及它们的组合、柯里化、Functor 等技术来降低系统复杂度，而 React、Rxjs、Cycle.js 正是这种理念的代言。让我们一起拥抱函数式编程，打开你程序的大门！</p></div><div class="page-edit"><!----><!----></div><div class="page-nav"><p class="inner"><!----><span class="next"><a href="/nonsense-front-end/doc/javascript-new-develop/js-QA.html">
          1.2 JavaScript与QA测试工程师
        </a> →
      </span></p></div></div></div></div>
    <script src="/nonsense-front-end/assets/js/4.1d0e363f.js" defer></script><script src="/nonsense-front-end/assets/js/app.f2e37e93.js" defer></script>
  </body>
</html>
